#!/usr/bin/env node

const readline = require('readline');

let position = 0;
let score = 0;
let obstaclePosition = 120;
let dinosaurHeight = 0;
const maxJumpHeight = 2;
let isJumpingUp = false;
let isJumpingDown = false;
const gameFieldHeight = 10;
const screenWidth = 100;
const minDistanceBetweenObstacles = 20;
let gameSpeed = 100;
let obstaclesPassed = 0;
let isInNightmareModeTransition = false;
let isNightmareModeActive = false;




readline.emitKeypressEvents(process.stdin);
process.stdin.setRawMode(true);


function draw() {
    console.clear();

    for (let i = 0; i < gameFieldHeight; i++) {
        let line = '';

        if (i === gameFieldHeight - dinosaurHeight - 1) {
            line += ' '.repeat(position) + 'D';
        } else {
            line += ' '.repeat(position + 1);
        }

        if (i === gameFieldHeight - 1) {
            let spaceAfterDino = obstaclePosition - position - 1;
            if (spaceAfterDino > 0) {
                line += ' '.repeat(spaceAfterDino);
            }
            line += 'O';
        }

        console.log(line);
    }

    console.log(`Score: ${score}`);
}

function jump() {
    isJumpingUp = true;

    let jumpInterval = setInterval(() => {
        if (dinosaurHeight < maxJumpHeight && isJumpingUp) {
            dinosaurHeight++;
            draw();
        } else {
            clearInterval(jumpInterval);
            isJumpingUp = false;
            isJumpingDown = true;
            fall();
        }
    }, 100);
}

function fall() {
    let fallInterval = setInterval(() => {
        if (dinosaurHeight > 0 && isJumpingDown) {
            dinosaurHeight--;
            draw();
        } else {
            clearInterval(fallInterval);
            isJumpingDown = false;
        }
    }, 100);
}

async function gameLoop() {
    obstaclePosition--;
    score++;

    if (obstaclePosition < 0) {
        obstaclesPassed++;
        generateObstacle();
    }

    if (obstaclesPassed === 3) {
        await showNightmareModeMessage();
        obstaclesPassed++;
    }

    if (obstaclePosition === position && dinosaurHeight === 0) {
        console.log('GAME OVER');
        process.exit();
    }

    draw();

    setTimeout(gameLoop, gameSpeed);
}

function generateObstacle() {
    obstaclePosition = screenWidth;

    let randomDistance = Math.floor(Math.random() * 20) + minDistanceBetweenObstacles;
    obstaclePosition += randomDistance;


    if (isNightmareModeActive) {
        gameSpeed *= 0.75;  
    } else {
        gameSpeed /= 2;
    }
}


function drawCenteredMessage(message) {
    console.clear();

    const middleLine = Math.floor(gameFieldHeight / 2);
    const paddingWidth = Math.floor((screenWidth - message.length) / 2);

    for (let i = 0; i < gameFieldHeight; i++) {
        if (i === middleLine) {
            console.log(' '.repeat(paddingWidth) + message);
        } else {
            console.log('');
        }
    }
}

function drawCenteredNightmareModeWithCountdown(countdown) {
    console.clear();

    const nightmareMessage = 'NIGHTMARE MODE';
    const paddingWidthForNightmare = Math.floor((screenWidth - nightmareMessage.length) / 2);
    const paddingWidthForCountdown = Math.floor((screenWidth - countdown.toString().length) / 2);

    const middleLineForNightmare = Math.floor(gameFieldHeight / 2) - 1;
    const middleLineForCountdown = Math.floor(gameFieldHeight / 2);

    for (let i = 0; i < gameFieldHeight; i++) {
        if (i === middleLineForNightmare) {
            console.log(' '.repeat(paddingWidthForNightmare) + nightmareMessage);
        } else if (i === middleLineForCountdown) {
            console.log(' '.repeat(paddingWidthForCountdown) + countdown);
        } else {
            console.log('');
        }
    }
}



async function showNightmareModeMessage() {
    isInNightmareModeTransition = true;

    for (let i = 5; i > 0; i--) {
        drawCenteredNightmareModeWithCountdown(i);
        await new Promise(resolve => setTimeout(resolve, 1000));
    }

    isNightmareModeActive = true; 
    isInNightmareModeTransition = false;
}




process.stdin.on('keypress', (str, key) => {
    if (isInNightmareModeTransition) return;

    if (key.name === 'q' || key.ctrl && key.name === 'c') {
        process.exit();
    }
    if (key.name === 'space' && !isJumpingUp && !isJumpingDown) {
        jump();
    }
});




gameLoop();
